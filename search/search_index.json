{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f\u6211\u90fd\u53ef\u4ee5\uff08As You Like\uff09\u7684 ACM \u6a21\u677f\u7f51\u7ad9\u3002 \u5f00\u79d1\u6280 to do list FFT \u4e0e\u5b57\u7b26\u4e32 SA SAM K \u77ed\u8def \u6700\u5927\u6d41 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 \u4e09\u5143\u73af/\u56db\u5143\u73af\u8ba1\u6570 \u591a\u6b21\u8be2\u95ee\u4e0d\u7ecf\u8fc7\u67d0\u4e00\u6761\u8fb9\u7684\u6700\u77ed\u8def\uff08ABC218F\uff09 \u51f8\u5305 \u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206 01 \u80cc\u5305\u4e8c\u8fdb\u5236\u4f18\u5316","title":"\u9996\u9875"},{"location":"#to-do-list","text":"FFT \u4e0e\u5b57\u7b26\u4e32 SA SAM K \u77ed\u8def \u6700\u5927\u6d41 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 \u4e09\u5143\u73af/\u56db\u5143\u73af\u8ba1\u6570 \u591a\u6b21\u8be2\u95ee\u4e0d\u7ecf\u8fc7\u67d0\u4e00\u6761\u8fb9\u7684\u6700\u77ed\u8def\uff08ABC218F\uff09 \u51f8\u5305 \u7ebf\u6bb5\u6811\u4e0a\u4e8c\u5206 01 \u80cc\u5305\u4e8c\u8fdb\u5236\u4f18\u5316","title":"\u5f00\u79d1\u6280 to do list"},{"location":"data_structure/BIT/","text":"\u6811\u72b6\u6570\u7ec4\u57fa\u7840 \u652f\u6301\u5355\u70b9\u4fee\u6539\u4e0e\u6c42\u533a\u95f4\u548c\uff0c\u5176\u4e2d\u533a\u95f4\u548c\u91c7\u7528\u524d\u7f00\u548c\u76f8\u51cf\u7684\u65b9\u5f0f\u3002 \u6811\u72b6\u6570\u7ec4\u57fa\u7840 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <cstdio> typedef long long int ll ; const int MAXN = 5e5 + 5 ; int n , m , opt , x , y ; int arr [ MAXN ]; ll sum [ MAXN ], BIT [ MAXN ]; int lowbit ( int xx ) { return xx & - xx ; } void update ( int place , int delta ) { for (; place <= n ; place += lowbit ( place )) { BIT [ place ] += delta ; } } int query ( int place ) { int tans = 0 ; for (; place >= 1 ; place -= lowbit ( place )) { tans += BIT [ place ]; } return tans ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , & arr [ i ]); sum [ i ] = sum [ i - 1 ] + arr [ i ]; } while ( m -- ) { scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 1 ) update ( x , y ); else { printf ( \"%lld \\n \" , query ( y ) - query ( x - 1 ) + sum [ y ] - sum [ x - 1 ]); } } return 0 ; }","title":"\u6811\u72b6\u6570\u7ec4"},{"location":"data_structure/BIT/#_1","text":"\u652f\u6301\u5355\u70b9\u4fee\u6539\u4e0e\u6c42\u533a\u95f4\u548c\uff0c\u5176\u4e2d\u533a\u95f4\u548c\u91c7\u7528\u524d\u7f00\u548c\u76f8\u51cf\u7684\u65b9\u5f0f\u3002 \u6811\u72b6\u6570\u7ec4\u57fa\u7840 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include <cstdio> typedef long long int ll ; const int MAXN = 5e5 + 5 ; int n , m , opt , x , y ; int arr [ MAXN ]; ll sum [ MAXN ], BIT [ MAXN ]; int lowbit ( int xx ) { return xx & - xx ; } void update ( int place , int delta ) { for (; place <= n ; place += lowbit ( place )) { BIT [ place ] += delta ; } } int query ( int place ) { int tans = 0 ; for (; place >= 1 ; place -= lowbit ( place )) { tans += BIT [ place ]; } return tans ; } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 1 ; i <= n ; ++ i ) { scanf ( \"%d\" , & arr [ i ]); sum [ i ] = sum [ i - 1 ] + arr [ i ]; } while ( m -- ) { scanf ( \"%d%d%d\" , & opt , & x , & y ); if ( opt == 1 ) update ( x , y ); else { printf ( \"%lld \\n \" , query ( y ) - query ( x - 1 ) + sum [ y ] - sum [ x - 1 ]); } } return 0 ; }","title":"\u6811\u72b6\u6570\u7ec4\u57fa\u7840"},{"location":"graph/dsu_on_tree/","text":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\uff08dsu on tree\uff09 \u57fa\u4e8e\u6811\u94fe\u5256\u5206\uff0c\u5728\u7edf\u8ba1\u7b54\u6848\u65f6\uff0c\u5206\u4ee5\u4e0b\u4e09\u6b65\uff1a \u9012\u5f52\u6c42\u89e3\u8f7b\u513f\u5b50\uff0c\u6d88\u9664\u8f7b\u513f\u5b50\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u3002 \u9012\u5f52\u6c42\u89e3\u91cd\u513f\u5b50\uff0c\u4e0d\u6d88\u9664\u5176\u5f71\u54cd\u3002 \u904d\u5386\u4ee5\u4eb2\u513f\u5b50\u4e3a\u6839\u7684\u5b50\u6811\uff0c\u7edf\u8ba1\u6240\u6709\u8282\u70b9\u3002 \u6a21\u677f\u6c42\u89e3\u7684\u662f\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u7f16\u53f7\u4e4b\u548c\u3002 dsu on tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <cstdio> #include <vector> const int MAXN = 1e5 + 5 ; int n , u , v ; int color [ MAXN ]; int fa [ MAXN ], depth [ MAXN ]; int sz [ MAXN ], hson [ MAXN ]; int cnt [ MAXN ], max_cnt ; long long int tans , ans [ MAXN ]; int L [ MAXN ], R [ MAXN ], arr [ MAXN ], dfn ; std :: vector < int > con [ MAXN ]; void get_tree ( int cur , int father ) { L [ cur ] = ++ dfn ; arr [ dfn ] = cur ; fa [ cur ] = father ; depth [ cur ] = depth [ father ] + 1 ; sz [ cur ] = 1 ; for ( int nxt : con [ cur ]) { if ( nxt != father ) { get_tree ( nxt , cur ); sz [ cur ] += sz [ nxt ]; if ( hson [ cur ] == 0 || sz [ nxt ] > sz [ hson [ cur ]]) hson [ cur ] = nxt ; } } R [ cur ] = dfn ; } void add ( int cur ) { ++ cnt [ color [ cur ]]; if ( cnt [ color [ cur ]] > max_cnt ) { max_cnt = cnt [ color [ cur ]]; tans = color [ cur ]; } else if ( cnt [ color [ cur ]] == max_cnt ) { tans += color [ cur ]; } } void del ( int cur ) { -- cnt [ color [ cur ]]; } void dsu ( int cur , int father , bool keep ) { // \u5148\u9012\u5f52\u8f7b\u513f\u5b50\uff0c\u6d88\u9664\u5f71\u54cd for ( int nxt : con [ cur ]) { if ( nxt != father && nxt != hson [ cur ]) dsu ( nxt , cur , false ); } // \u9012\u5f52\u91cd\u513f\u5b50\uff0c\u4e0d\u6d88\u9664\u5f71\u54cd if ( hson [ cur ]) dsu ( hson [ cur ], cur , true ); // \u5c06\u8f7b\u5b50\u6811\u4e0a\u7684\u8282\u70b9\u7edf\u8ba1\u8fdb\u6765 for ( int nxt : con [ cur ]) { if ( nxt == father || nxt == hson [ cur ]) continue ; for ( int i = L [ nxt ]; i <= R [ nxt ]; ++ i ) { add ( arr [ i ]); } } // \u7edf\u8ba1\u81ea\u5df1 add ( cur ); ans [ cur ] = tans ; // \u6d88\u9664\u5f71\u54cd if ( ! keep ) { for ( int i = L [ cur ]; i <= R [ cur ]; ++ i ) { del ( arr [ i ]); } max_cnt = 0 ; tans = 0 ; } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & color [ i ]); for ( int i = 1 ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); con [ u ]. push_back ( v ); con [ v ]. push_back ( u ); } get_tree ( 1 , 0 ); dsu ( 1 , 0 , true ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld \" , ans [ i ]); } return 0 ; }","title":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76"},{"location":"graph/dsu_on_tree/#dsu-on-tree","text":"\u57fa\u4e8e\u6811\u94fe\u5256\u5206\uff0c\u5728\u7edf\u8ba1\u7b54\u6848\u65f6\uff0c\u5206\u4ee5\u4e0b\u4e09\u6b65\uff1a \u9012\u5f52\u6c42\u89e3\u8f7b\u513f\u5b50\uff0c\u6d88\u9664\u8f7b\u513f\u5b50\u5bf9\u7b54\u6848\u7684\u5f71\u54cd\u3002 \u9012\u5f52\u6c42\u89e3\u91cd\u513f\u5b50\uff0c\u4e0d\u6d88\u9664\u5176\u5f71\u54cd\u3002 \u904d\u5386\u4ee5\u4eb2\u513f\u5b50\u4e3a\u6839\u7684\u5b50\u6811\uff0c\u7edf\u8ba1\u6240\u6709\u8282\u70b9\u3002 \u6a21\u677f\u6c42\u89e3\u7684\u662f\u4ee5\u6bcf\u4e2a\u8282\u70b9\u4e3a\u6839\u7684\u5b50\u6811\u4e2d\uff0c\u51fa\u73b0\u6b21\u6570\u6700\u591a\u7684\u989c\u8272\u7684\u7f16\u53f7\u4e4b\u548c\u3002 dsu on tree 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 #include <cstdio> #include <vector> const int MAXN = 1e5 + 5 ; int n , u , v ; int color [ MAXN ]; int fa [ MAXN ], depth [ MAXN ]; int sz [ MAXN ], hson [ MAXN ]; int cnt [ MAXN ], max_cnt ; long long int tans , ans [ MAXN ]; int L [ MAXN ], R [ MAXN ], arr [ MAXN ], dfn ; std :: vector < int > con [ MAXN ]; void get_tree ( int cur , int father ) { L [ cur ] = ++ dfn ; arr [ dfn ] = cur ; fa [ cur ] = father ; depth [ cur ] = depth [ father ] + 1 ; sz [ cur ] = 1 ; for ( int nxt : con [ cur ]) { if ( nxt != father ) { get_tree ( nxt , cur ); sz [ cur ] += sz [ nxt ]; if ( hson [ cur ] == 0 || sz [ nxt ] > sz [ hson [ cur ]]) hson [ cur ] = nxt ; } } R [ cur ] = dfn ; } void add ( int cur ) { ++ cnt [ color [ cur ]]; if ( cnt [ color [ cur ]] > max_cnt ) { max_cnt = cnt [ color [ cur ]]; tans = color [ cur ]; } else if ( cnt [ color [ cur ]] == max_cnt ) { tans += color [ cur ]; } } void del ( int cur ) { -- cnt [ color [ cur ]]; } void dsu ( int cur , int father , bool keep ) { // \u5148\u9012\u5f52\u8f7b\u513f\u5b50\uff0c\u6d88\u9664\u5f71\u54cd for ( int nxt : con [ cur ]) { if ( nxt != father && nxt != hson [ cur ]) dsu ( nxt , cur , false ); } // \u9012\u5f52\u91cd\u513f\u5b50\uff0c\u4e0d\u6d88\u9664\u5f71\u54cd if ( hson [ cur ]) dsu ( hson [ cur ], cur , true ); // \u5c06\u8f7b\u5b50\u6811\u4e0a\u7684\u8282\u70b9\u7edf\u8ba1\u8fdb\u6765 for ( int nxt : con [ cur ]) { if ( nxt == father || nxt == hson [ cur ]) continue ; for ( int i = L [ nxt ]; i <= R [ nxt ]; ++ i ) { add ( arr [ i ]); } } // \u7edf\u8ba1\u81ea\u5df1 add ( cur ); ans [ cur ] = tans ; // \u6d88\u9664\u5f71\u54cd if ( ! keep ) { for ( int i = L [ cur ]; i <= R [ cur ]; ++ i ) { del ( arr [ i ]); } max_cnt = 0 ; tans = 0 ; } } int main () { scanf ( \"%d\" , & n ); for ( int i = 1 ; i <= n ; ++ i ) scanf ( \"%d\" , & color [ i ]); for ( int i = 1 ; i < n ; ++ i ) { scanf ( \"%d%d\" , & u , & v ); con [ u ]. push_back ( v ); con [ v ]. push_back ( u ); } get_tree ( 1 , 0 ); dsu ( 1 , 0 , true ); for ( int i = 1 ; i <= n ; ++ i ) { printf ( \"%lld \" , ans [ i ]); } return 0 ; }","title":"\u6811\u4e0a\u542f\u53d1\u5f0f\u5408\u5e76\uff08dsu on tree\uff09"},{"location":"math/FFT/","text":"\u9012\u5f52 FFT \u7ed9\u5b9a\u4e24\u4e2a\u591a\u9879\u5f0f\uff0c\u5feb\u901f\u76f8\u4e58\u3002\u5148\u505a\u4e00\u904d FFT \u628a\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\u4ece\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u5f62\u5f0f\uff0c\u518d\u7528 \u7684\u65f6\u95f4\u5c06\u70b9\u503c\u76f8\u4e58\uff0c\u5f97\u5230\u7ed3\u679c\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u5f62\u5f0f\u3002\u5bf9\u7ed3\u679c\u591a\u9879\u5f0f\u505a\u4e00\u904d\u9006 FFT \u5373\u53ef\u5f97\u5230\u5176\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u7531\u4e8e\u5355\u4f4d\u6839\u5177\u6709\u7684\u7279\u6b8a\u7684\u6027\u8d28\uff0cFFT \u53ef\u4ee5\u901a\u8fc7\u5206\u6cbb\u5728 \\(\\Theta(n\\log n)\\) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u3002 \u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cmath> #include <complex> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { if ( lmt == 1 ) return ; comp odd [ lmt >> 1 ], eve [ lmt >> 1 ]; for ( int i = 0 ; i < lmt ; i += 2 ) { eve [ i >> 1 ] = arr [ i ]; odd [ i >> 1 ] = arr [ i + 1 ]; } FFT ( lmt >> 1 , odd , opt ); FFT ( lmt >> 1 , eve , opt ); comp cur ( 1 , 0 ), step ( cos ( 2.0 * pi / lmt ), opt * sin ( 2.0 * pi / lmt )); for ( int i = 0 ; i < lmt / 2 ; ++ i , cur *= step ) { arr [ i ] = eve [ i ] + cur * odd [ i ]; arr [ i + lmt / 2 ] = eve [ i ] - cur * odd [ i ]; } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real () / lmt )); } return 0 ; } \u975e\u9012\u5f52 FFT\uff08\u8774\u8776\u4f18\u5316\uff09 \u89c2\u5bdf\u9012\u5f52 FFT \u7684\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u90fd\u662f\u5c06\u591a\u9879\u5f0f\u7684\u5947\u6570\u6b21\u9879\u548c\u5076\u6570\u6b21\u9879\u7cfb\u6570\u5206\u5f00\uff0c\u4e00\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u6765\u6a21\u62df\u4e00\u4e0b\u62c6\u5206\u4e0e\u5408\u5e76\u7684\u8fc7\u7a0b\u3002\u5047\u8bbe\u591a\u9879\u5f0f\u6b21\u6570\u4e3a \\(8\\) \u3002 0,1,2,3,4,5,6,7 0,2,4,6 1,3,5,7 0,4 2,6 1,5 3,7 0 4 2 6 1 5 3 7 \u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff1a\u539f\u5e8f\u5217\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u4e0b\u6807\u7528\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u5c06\u4e8c\u8fdb\u5236\u4e3a\u7ffb\u8f6c\u4e4b\u540e\uff0c\u5f97\u5230\u7684\u6570\u5c31\u662f\u62c6\u5206\u5230\u6700\u540e\u6240\u5728\u7684\u4f4d\u7f6e\u3002\u5982\u4e0a\u56fe\u4e2d \\(1\\) \u662f 001 \uff0c \\(4\\) \u662f 100 \uff0c\u4e8c\u8fdb\u5236\u6070\u597d\u7ffb\u8f6c\uff0c\u800c\u5728\u539f\u5e8f\u5217\u4e0e\u6700\u7ec8\u5e8f\u5217\u4e2d\uff0c \\(1\\) \u548c \\(4\\) \u7684\u4f4d\u7f6e\u6070\u597d\u4e92\u6362\u3002\u4e8e\u662f\u8003\u8651\u5982\u4f55\u6c42\u51fa\u4e0b\u6807 \\(i\\) \u5bf9\u5e94\u7684\u4e92\u6362\u4f4d\u7f6e rev[i] \u3002 \u5982\u679c\u6211\u4eec\u8981\u5c06 \\(i\\) \u7684\u4e8c\u8fdb\u5236\u4f4d\u7ffb\u8f6c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u62c6\u6210\u4e24\u90e8\u5206\uff0c\u6700\u540e\u4e00\u4f4d\u548c\u5269\u4e0b\u7684\u6240\u6709\u4f4d\uff08\u79f0\u4e4b\u4e3a\u5269\u4f59\u4f4d\uff09\u3002\u5148\u5c06\u5269\u4f59\u4f4d\u7ffb\u8f6c\uff0c\u7136\u540e\u5c06\u6700\u540e\u4e00\u4f4d\u653e\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u7684\u524d\u9762\uff0c\u5269\u4f59\u4f4d\u7ffb\u8f6c\u7684\u7ed3\u679c\u4e3a\uff1a rev[i >> 1] >> 1 \uff0c\u518d\u770b\u60c5\u51b5\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u4e4b\u524d\u52a0 \\(1\\) \u5373\u53ef\u3002 \u975e\u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include <cstdio> #include <cmath> #include <complex> #include <algorithm> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; int rev [ MAXN << 2 ]; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { for ( int i = 0 ; i < lmt ; ++ i ) { if ( rev [ i ] > i ) std :: swap ( arr [ i ], arr [ rev [ i ]]); } for ( int len = 2 ; len <= lmt ; len <<= 1 ) { comp step ( cos ( 2 * pi / len ), opt * sin ( 2 * pi / len )); for ( int w = 0 ; w < lmt ; w += len ) { comp cur ( 1 , 0 ); for ( int i = w ; i < w + len / 2 ; ++ i ) { comp t1 = arr [ i ]; comp t2 = cur * arr [ i + len / 2 ]; arr [ i ] = t1 + t2 ; arr [ i + len / 2 ] = t1 - t2 ; cur *= step ; } } } if ( opt == -1 ) { for ( int i = 0 ; i < lmt ; ++ i ) { arr [ i ]. real ( arr [ i ]. real () / lmt ); } } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } for ( int i = 1 ; i < lmt ; ++ i ) { rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | ( i & 1 ? lmt >> 1 : 0 ); } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real ())); } return 0 ; } FFT \u4e0e\u5b57\u7b26\u4e32\u5339\u914d","title":"FFT"},{"location":"math/FFT/#fft","text":"\u7ed9\u5b9a\u4e24\u4e2a\u591a\u9879\u5f0f\uff0c\u5feb\u901f\u76f8\u4e58\u3002\u5148\u505a\u4e00\u904d FFT \u628a\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\u4ece\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u5f62\u5f0f\uff0c\u518d\u7528 \u7684\u65f6\u95f4\u5c06\u70b9\u503c\u76f8\u4e58\uff0c\u5f97\u5230\u7ed3\u679c\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u5f62\u5f0f\u3002\u5bf9\u7ed3\u679c\u591a\u9879\u5f0f\u505a\u4e00\u904d\u9006 FFT \u5373\u53ef\u5f97\u5230\u5176\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u7531\u4e8e\u5355\u4f4d\u6839\u5177\u6709\u7684\u7279\u6b8a\u7684\u6027\u8d28\uff0cFFT \u53ef\u4ee5\u901a\u8fc7\u5206\u6cbb\u5728 \\(\\Theta(n\\log n)\\) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u3002 \u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cmath> #include <complex> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { if ( lmt == 1 ) return ; comp odd [ lmt >> 1 ], eve [ lmt >> 1 ]; for ( int i = 0 ; i < lmt ; i += 2 ) { eve [ i >> 1 ] = arr [ i ]; odd [ i >> 1 ] = arr [ i + 1 ]; } FFT ( lmt >> 1 , odd , opt ); FFT ( lmt >> 1 , eve , opt ); comp cur ( 1 , 0 ), step ( cos ( 2.0 * pi / lmt ), opt * sin ( 2.0 * pi / lmt )); for ( int i = 0 ; i < lmt / 2 ; ++ i , cur *= step ) { arr [ i ] = eve [ i ] + cur * odd [ i ]; arr [ i + lmt / 2 ] = eve [ i ] - cur * odd [ i ]; } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real () / lmt )); } return 0 ; }","title":"\u9012\u5f52 FFT"},{"location":"math/FFT/#fft_1","text":"\u89c2\u5bdf\u9012\u5f52 FFT \u7684\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u90fd\u662f\u5c06\u591a\u9879\u5f0f\u7684\u5947\u6570\u6b21\u9879\u548c\u5076\u6570\u6b21\u9879\u7cfb\u6570\u5206\u5f00\uff0c\u4e00\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u6765\u6a21\u62df\u4e00\u4e0b\u62c6\u5206\u4e0e\u5408\u5e76\u7684\u8fc7\u7a0b\u3002\u5047\u8bbe\u591a\u9879\u5f0f\u6b21\u6570\u4e3a \\(8\\) \u3002 0,1,2,3,4,5,6,7 0,2,4,6 1,3,5,7 0,4 2,6 1,5 3,7 0 4 2 6 1 5 3 7 \u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff1a\u539f\u5e8f\u5217\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u4e0b\u6807\u7528\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u5c06\u4e8c\u8fdb\u5236\u4e3a\u7ffb\u8f6c\u4e4b\u540e\uff0c\u5f97\u5230\u7684\u6570\u5c31\u662f\u62c6\u5206\u5230\u6700\u540e\u6240\u5728\u7684\u4f4d\u7f6e\u3002\u5982\u4e0a\u56fe\u4e2d \\(1\\) \u662f 001 \uff0c \\(4\\) \u662f 100 \uff0c\u4e8c\u8fdb\u5236\u6070\u597d\u7ffb\u8f6c\uff0c\u800c\u5728\u539f\u5e8f\u5217\u4e0e\u6700\u7ec8\u5e8f\u5217\u4e2d\uff0c \\(1\\) \u548c \\(4\\) \u7684\u4f4d\u7f6e\u6070\u597d\u4e92\u6362\u3002\u4e8e\u662f\u8003\u8651\u5982\u4f55\u6c42\u51fa\u4e0b\u6807 \\(i\\) \u5bf9\u5e94\u7684\u4e92\u6362\u4f4d\u7f6e rev[i] \u3002 \u5982\u679c\u6211\u4eec\u8981\u5c06 \\(i\\) \u7684\u4e8c\u8fdb\u5236\u4f4d\u7ffb\u8f6c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u62c6\u6210\u4e24\u90e8\u5206\uff0c\u6700\u540e\u4e00\u4f4d\u548c\u5269\u4e0b\u7684\u6240\u6709\u4f4d\uff08\u79f0\u4e4b\u4e3a\u5269\u4f59\u4f4d\uff09\u3002\u5148\u5c06\u5269\u4f59\u4f4d\u7ffb\u8f6c\uff0c\u7136\u540e\u5c06\u6700\u540e\u4e00\u4f4d\u653e\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u7684\u524d\u9762\uff0c\u5269\u4f59\u4f4d\u7ffb\u8f6c\u7684\u7ed3\u679c\u4e3a\uff1a rev[i >> 1] >> 1 \uff0c\u518d\u770b\u60c5\u51b5\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u4e4b\u524d\u52a0 \\(1\\) \u5373\u53ef\u3002 \u975e\u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include <cstdio> #include <cmath> #include <complex> #include <algorithm> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; int rev [ MAXN << 2 ]; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { for ( int i = 0 ; i < lmt ; ++ i ) { if ( rev [ i ] > i ) std :: swap ( arr [ i ], arr [ rev [ i ]]); } for ( int len = 2 ; len <= lmt ; len <<= 1 ) { comp step ( cos ( 2 * pi / len ), opt * sin ( 2 * pi / len )); for ( int w = 0 ; w < lmt ; w += len ) { comp cur ( 1 , 0 ); for ( int i = w ; i < w + len / 2 ; ++ i ) { comp t1 = arr [ i ]; comp t2 = cur * arr [ i + len / 2 ]; arr [ i ] = t1 + t2 ; arr [ i + len / 2 ] = t1 - t2 ; cur *= step ; } } } if ( opt == -1 ) { for ( int i = 0 ; i < lmt ; ++ i ) { arr [ i ]. real ( arr [ i ]. real () / lmt ); } } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } for ( int i = 1 ; i < lmt ; ++ i ) { rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | ( i & 1 ? lmt >> 1 : 0 ); } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real ())); } return 0 ; }","title":"\u975e\u9012\u5f52 FFT\uff08\u8774\u8776\u4f18\u5316\uff09"},{"location":"math/FFT/#fft_2","text":"","title":"FFT \u4e0e\u5b57\u7b26\u4e32\u5339\u914d"},{"location":"string/trie/","text":"Trie \u6811\u5b9e\u73b0 \u652f\u6301\u5b57\u7b26\u4e32\u7684\u63d2\u5165\u548c\u67e5\u627e\u64cd\u4f5c\u3002 \u57fa\u672c trie \u6811\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <cstdio> #include <cstring> const int MAXN = 5e5 + 5 ; int n , m ; char s [ 55 ]; int tr [ MAXN ][ 26 ], flg [ MAXN ], tot ; void ins ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) tr [ cur ][ nxt ] = ++ tot ; cur = tr [ cur ][ nxt ]; } flg [ cur ] = 1 ; } int query ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) return 0 ; cur = tr [ cur ][ nxt ]; } int ret = flg [ cur ]; if ( flg [ cur ] == 1 ) flg [ cur ] = 2 ; return ret ; } int main () { scanf ( \"%d\" , & n ); while ( n -- ) { scanf ( \"%s\" , s + 1 ); ins ( s , strlen ( s + 1 )); } scanf ( \"%d\" , & m ); while ( m -- ) { scanf ( \"%s\" , s + 1 ); int tmp = query ( s , strlen ( s + 1 )); if ( tmp == 0 ) printf ( \"WRONG \\n \" ); if ( tmp == 1 ) printf ( \"OK \\n \" ); if ( tmp == 2 ) printf ( \"REPEAT \\n \" ); } return 0 ; }","title":"Trie \u6811"},{"location":"string/trie/#trie","text":"\u652f\u6301\u5b57\u7b26\u4e32\u7684\u63d2\u5165\u548c\u67e5\u627e\u64cd\u4f5c\u3002 \u57fa\u672c trie \u6811\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <cstdio> #include <cstring> const int MAXN = 5e5 + 5 ; int n , m ; char s [ 55 ]; int tr [ MAXN ][ 26 ], flg [ MAXN ], tot ; void ins ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) tr [ cur ][ nxt ] = ++ tot ; cur = tr [ cur ][ nxt ]; } flg [ cur ] = 1 ; } int query ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) return 0 ; cur = tr [ cur ][ nxt ]; } int ret = flg [ cur ]; if ( flg [ cur ] == 1 ) flg [ cur ] = 2 ; return ret ; } int main () { scanf ( \"%d\" , & n ); while ( n -- ) { scanf ( \"%s\" , s + 1 ); ins ( s , strlen ( s + 1 )); } scanf ( \"%d\" , & m ); while ( m -- ) { scanf ( \"%s\" , s + 1 ); int tmp = query ( s , strlen ( s + 1 )); if ( tmp == 0 ) printf ( \"WRONG \\n \" ); if ( tmp == 1 ) printf ( \"OK \\n \" ); if ( tmp == 2 ) printf ( \"REPEAT \\n \" ); } return 0 ; }","title":"Trie \u6811\u5b9e\u73b0"}]}