{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f\u6211\u90fd\u53ef\u4ee5\uff08As You Like\uff09\u7684 ACM \u6a21\u677f\u7f51\u7ad9\u3002 \u5f00\u79d1\u6280 to do list FFT \u4e0e\u5b57\u7b26\u4e32 SA SAM K \u77ed\u8def \u6700\u5927\u6d41 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41 Material color palette \u989c\u8272\u4e3b\u9898 Primary colors \u4e3b\u8272 \u9ed8\u8ba4\u4e3a Light Blue \u70b9\u51fb\u8272\u5757\u53ef\u66f4\u6362\u4e3b\u9898\u7684\u4e3b\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) }) Accent colors \u8f85\u52a9\u8272 \u9ed8\u8ba4\u4e3a red \u70b9\u51fb\u8272\u5757\u66f4\u6362\u4e3b\u9898\u7684\u8f85\u52a9\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) }) // #758 document.getElementsByClassName('md-nav__title')[1].click()","title":"\u9996\u9875"},{"location":"#to-do-list","text":"FFT \u4e0e\u5b57\u7b26\u4e32 SA SAM K \u77ed\u8def \u6700\u5927\u6d41 \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41","title":"\u5f00\u79d1\u6280 to do list"},{"location":"#material-color-palette","text":"","title":"Material color palette \u989c\u8272\u4e3b\u9898"},{"location":"#primary-colors","text":"\u9ed8\u8ba4\u4e3a Light Blue \u70b9\u51fb\u8272\u5757\u53ef\u66f4\u6362\u4e3b\u9898\u7684\u4e3b\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange Brown Grey Blue Grey White var buttons = document.querySelectorAll(\"button[data-md-color-primary]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorPrimary = this.dataset.mdColorPrimary; localStorage.setItem(\"data-md-color-primary\",this.dataset.mdColorPrimary); }) })","title":"Primary colors \u4e3b\u8272"},{"location":"#accent-colors","text":"\u9ed8\u8ba4\u4e3a red \u70b9\u51fb\u8272\u5757\u66f4\u6362\u4e3b\u9898\u7684\u8f85\u52a9\u8272 Red Pink Purple Deep Purple Indigo Blue Light Blue Cyan Teal Green Light Green Lime Yellow Amber Orange Deep Orange var buttons = document.querySelectorAll(\"button[data-md-color-accent]\"); Array.prototype.forEach.call(buttons, function(button) { button.addEventListener(\"click\", function() { document.body.dataset.mdColorAccent = this.dataset.mdColorAccent; localStorage.setItem(\"data-md-color-accent\",this.dataset.mdColorAccent); }) }) // #758 document.getElementsByClassName('md-nav__title')[1].click()","title":"Accent colors \u8f85\u52a9\u8272"},{"location":"math/FFT/","text":"\u9012\u5f52 FFT \u7ed9\u5b9a\u4e24\u4e2a\u591a\u9879\u5f0f\uff0c\u5feb\u901f\u76f8\u4e58\u3002\u5148\u505a\u4e00\u904d FFT \u628a\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\u4ece\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u5f62\u5f0f\uff0c\u518d\u7528 \u7684\u65f6\u95f4\u5c06\u70b9\u503c\u76f8\u4e58\uff0c\u5f97\u5230\u7ed3\u679c\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u5f62\u5f0f\u3002\u5bf9\u7ed3\u679c\u591a\u9879\u5f0f\u505a\u4e00\u904d\u9006 FFT \u5373\u53ef\u5f97\u5230\u5176\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u7531\u4e8e\u5355\u4f4d\u6839\u5177\u6709\u7684\u7279\u6b8a\u7684\u6027\u8d28\uff0cFFT \u53ef\u4ee5\u901a\u8fc7\u5206\u6cbb\u5728 \\(\\Theta(n\\log n)\\) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u3002 \u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cmath> #include <complex> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { if ( lmt == 1 ) return ; comp odd [ lmt >> 1 ], eve [ lmt >> 1 ]; for ( int i = 0 ; i < lmt ; i += 2 ) { eve [ i >> 1 ] = arr [ i ]; odd [ i >> 1 ] = arr [ i + 1 ]; } FFT ( lmt >> 1 , odd , opt ); FFT ( lmt >> 1 , eve , opt ); comp cur ( 1 , 0 ), step ( cos ( 2.0 * pi / lmt ), opt * sin ( 2.0 * pi / lmt )); for ( int i = 0 ; i < lmt / 2 ; ++ i , cur *= step ) { arr [ i ] = eve [ i ] + cur * odd [ i ]; arr [ i + lmt / 2 ] = eve [ i ] - cur * odd [ i ]; } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real () / lmt )); } return 0 ; } \u975e\u9012\u5f52 FFT\uff08\u8774\u8776\u4f18\u5316\uff09 \u89c2\u5bdf\u9012\u5f52 FFT \u7684\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u90fd\u662f\u5c06\u591a\u9879\u5f0f\u7684\u5947\u6570\u6b21\u9879\u548c\u5076\u6570\u6b21\u9879\u7cfb\u6570\u5206\u5f00\uff0c\u4e00\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u6765\u6a21\u62df\u4e00\u4e0b\u62c6\u5206\u4e0e\u5408\u5e76\u7684\u8fc7\u7a0b\u3002\u5047\u8bbe\u591a\u9879\u5f0f\u6b21\u6570\u4e3a \\(8\\) \u3002 0,1,2,3,4,5,6,7 0,2,4,6 1,3,5,7 0,4 2,6 1,5 3,7 0 4 2 6 1 5 3 7 \u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff1a\u539f\u5e8f\u5217\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u4e0b\u6807\u7528\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u5c06\u4e8c\u8fdb\u5236\u4e3a\u7ffb\u8f6c\u4e4b\u540e\uff0c\u5f97\u5230\u7684\u6570\u5c31\u662f\u62c6\u5206\u5230\u6700\u540e\u6240\u5728\u7684\u4f4d\u7f6e\u3002\u5982\u4e0a\u56fe\u4e2d \\(1\\) \u662f 001 \uff0c \\(4\\) \u662f 100 \uff0c\u4e8c\u8fdb\u5236\u6070\u597d\u7ffb\u8f6c\uff0c\u800c\u5728\u539f\u5e8f\u5217\u4e0e\u6700\u7ec8\u5e8f\u5217\u4e2d\uff0c \\(1\\) \u548c \\(4\\) \u7684\u4f4d\u7f6e\u6070\u597d\u4e92\u6362\u3002\u4e8e\u662f\u8003\u8651\u5982\u4f55\u6c42\u51fa\u4e0b\u6807 \\(i\\) \u5bf9\u5e94\u7684\u4e92\u6362\u4f4d\u7f6e rev[i] \u3002 \u5982\u679c\u6211\u4eec\u8981\u5c06 \\(i\\) \u7684\u4e8c\u8fdb\u5236\u4f4d\u7ffb\u8f6c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u62c6\u6210\u4e24\u90e8\u5206\uff0c\u6700\u540e\u4e00\u4f4d\u548c\u5269\u4e0b\u7684\u6240\u6709\u4f4d\uff08\u79f0\u4e4b\u4e3a\u5269\u4f59\u4f4d\uff09\u3002\u5148\u5c06\u5269\u4f59\u4f4d\u7ffb\u8f6c\uff0c\u7136\u540e\u5c06\u6700\u540e\u4e00\u4f4d\u653e\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u7684\u524d\u9762\uff0c\u5269\u4f59\u4f4d\u7ffb\u8f6c\u7684\u7ed3\u679c\u4e3a\uff1a rev[i >> 1] >> 1 \uff0c\u518d\u770b\u60c5\u51b5\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u4e4b\u524d\u52a0 \\(1\\) \u5373\u53ef\u3002 \u975e\u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include <cstdio> #include <cmath> #include <complex> #include <algorithm> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; int rev [ MAXN << 2 ]; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { for ( int i = 0 ; i < lmt ; ++ i ) { if ( rev [ i ] > i ) std :: swap ( arr [ i ], arr [ rev [ i ]]); } for ( int len = 2 ; len <= lmt ; len <<= 1 ) { comp step ( cos ( 2 * pi / len ), opt * sin ( 2 * pi / len )); for ( int w = 0 ; w < lmt ; w += len ) { comp cur ( 1 , 0 ); for ( int i = w ; i < w + len / 2 ; ++ i ) { comp t1 = arr [ i ]; comp t2 = cur * arr [ i + len / 2 ]; arr [ i ] = t1 + t2 ; arr [ i + len / 2 ] = t1 - t2 ; cur *= step ; } } } if ( opt == -1 ) { for ( int i = 0 ; i < lmt ; ++ i ) { arr [ i ]. real ( arr [ i ]. real () / lmt ); } } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } for ( int i = 1 ; i < lmt ; ++ i ) { rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | ( i & 1 ? lmt >> 1 : 0 ); } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real ())); } return 0 ; } FFT \u4e0e\u5b57\u7b26\u4e32\u5339\u914d","title":"FFT"},{"location":"math/FFT/#fft","text":"\u7ed9\u5b9a\u4e24\u4e2a\u591a\u9879\u5f0f\uff0c\u5feb\u901f\u76f8\u4e58\u3002\u5148\u505a\u4e00\u904d FFT \u628a\u7ed9\u5b9a\u7684\u591a\u9879\u5f0f\u4ece\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u8f6c\u4e3a\u70b9\u503c\u8868\u793a\u5f62\u5f0f\uff0c\u518d\u7528 \u7684\u65f6\u95f4\u5c06\u70b9\u503c\u76f8\u4e58\uff0c\u5f97\u5230\u7ed3\u679c\u591a\u9879\u5f0f\u7684\u70b9\u503c\u8868\u793a\u5f62\u5f0f\u3002\u5bf9\u7ed3\u679c\u591a\u9879\u5f0f\u505a\u4e00\u904d\u9006 FFT \u5373\u53ef\u5f97\u5230\u5176\u7cfb\u6570\u8868\u793a\u5f62\u5f0f\u3002 \u7531\u4e8e\u5355\u4f4d\u6839\u5177\u6709\u7684\u7279\u6b8a\u7684\u6027\u8d28\uff0cFFT \u53ef\u4ee5\u901a\u8fc7\u5206\u6cbb\u5728 \\(\\Theta(n\\log n)\\) \u7684\u65f6\u95f4\u5185\u5b8c\u6210\u3002 \u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <cstdio> #include <cmath> #include <complex> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { if ( lmt == 1 ) return ; comp odd [ lmt >> 1 ], eve [ lmt >> 1 ]; for ( int i = 0 ; i < lmt ; i += 2 ) { eve [ i >> 1 ] = arr [ i ]; odd [ i >> 1 ] = arr [ i + 1 ]; } FFT ( lmt >> 1 , odd , opt ); FFT ( lmt >> 1 , eve , opt ); comp cur ( 1 , 0 ), step ( cos ( 2.0 * pi / lmt ), opt * sin ( 2.0 * pi / lmt )); for ( int i = 0 ; i < lmt / 2 ; ++ i , cur *= step ) { arr [ i ] = eve [ i ] + cur * odd [ i ]; arr [ i + lmt / 2 ] = eve [ i ] - cur * odd [ i ]; } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real () / lmt )); } return 0 ; }","title":"\u9012\u5f52 FFT"},{"location":"math/FFT/#fft_1","text":"\u89c2\u5bdf\u9012\u5f52 FFT \u7684\u8fc7\u7a0b\uff0c\u6bcf\u6b21\u90fd\u662f\u5c06\u591a\u9879\u5f0f\u7684\u5947\u6570\u6b21\u9879\u548c\u5076\u6570\u6b21\u9879\u7cfb\u6570\u5206\u5f00\uff0c\u4e00\u76f4\u5230\u53ea\u5269\u4e0b\u4e00\u4e2a\u6570\uff0c\u6211\u4eec\u6765\u6a21\u62df\u4e00\u4e0b\u62c6\u5206\u4e0e\u5408\u5e76\u7684\u8fc7\u7a0b\u3002\u5047\u8bbe\u591a\u9879\u5f0f\u6b21\u6570\u4e3a \\(8\\) \u3002 0,1,2,3,4,5,6,7 0,2,4,6 1,3,5,7 0,4 2,6 1,5 3,7 0 4 2 6 1 5 3 7 \u53ef\u4ee5\u53d1\u73b0\u89c4\u5f8b\uff1a\u539f\u5e8f\u5217\u7684\u6bcf\u4e2a\u5143\u7d20\u7684\u4e0b\u6807\u7528\u4e8c\u8fdb\u5236\u8868\u793a\uff0c\u5c06\u4e8c\u8fdb\u5236\u4e3a\u7ffb\u8f6c\u4e4b\u540e\uff0c\u5f97\u5230\u7684\u6570\u5c31\u662f\u62c6\u5206\u5230\u6700\u540e\u6240\u5728\u7684\u4f4d\u7f6e\u3002\u5982\u4e0a\u56fe\u4e2d \\(1\\) \u662f 001 \uff0c \\(4\\) \u662f 100 \uff0c\u4e8c\u8fdb\u5236\u6070\u597d\u7ffb\u8f6c\uff0c\u800c\u5728\u539f\u5e8f\u5217\u4e0e\u6700\u7ec8\u5e8f\u5217\u4e2d\uff0c \\(1\\) \u548c \\(4\\) \u7684\u4f4d\u7f6e\u6070\u597d\u4e92\u6362\u3002\u4e8e\u662f\u8003\u8651\u5982\u4f55\u6c42\u51fa\u4e0b\u6807 \\(i\\) \u5bf9\u5e94\u7684\u4e92\u6362\u4f4d\u7f6e rev[i] \u3002 \u5982\u679c\u6211\u4eec\u8981\u5c06 \\(i\\) \u7684\u4e8c\u8fdb\u5236\u4f4d\u7ffb\u8f6c\uff0c\u6211\u4eec\u53ef\u4ee5\u5c06\u5176\u62c6\u6210\u4e24\u90e8\u5206\uff0c\u6700\u540e\u4e00\u4f4d\u548c\u5269\u4e0b\u7684\u6240\u6709\u4f4d\uff08\u79f0\u4e4b\u4e3a\u5269\u4f59\u4f4d\uff09\u3002\u5148\u5c06\u5269\u4f59\u4f4d\u7ffb\u8f6c\uff0c\u7136\u540e\u5c06\u6700\u540e\u4e00\u4f4d\u653e\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u7684\u524d\u9762\uff0c\u5269\u4f59\u4f4d\u7ffb\u8f6c\u7684\u7ed3\u679c\u4e3a\uff1a rev[i >> 1] >> 1 \uff0c\u518d\u770b\u60c5\u51b5\u5728\u7ffb\u8f6c\u540e\u7684\u5269\u4f59\u4f4d\u4e4b\u524d\u52a0 \\(1\\) \u5373\u53ef\u3002 \u975e\u9012\u5f52 FFT 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include <cstdio> #include <cmath> #include <complex> #include <algorithm> typedef std :: complex < double > comp ; const double pi = acos ( -1.0 ); const int MAXN = 1e6 + 5 ; int n , m , k ; int rev [ MAXN << 2 ]; comp F [ MAXN << 2 ], G [ MAXN << 2 ]; void FFT ( int lmt , comp arr [], int opt ) { for ( int i = 0 ; i < lmt ; ++ i ) { if ( rev [ i ] > i ) std :: swap ( arr [ i ], arr [ rev [ i ]]); } for ( int len = 2 ; len <= lmt ; len <<= 1 ) { comp step ( cos ( 2 * pi / len ), opt * sin ( 2 * pi / len )); for ( int w = 0 ; w < lmt ; w += len ) { comp cur ( 1 , 0 ); for ( int i = w ; i < w + len / 2 ; ++ i ) { comp t1 = arr [ i ]; comp t2 = cur * arr [ i + len / 2 ]; arr [ i ] = t1 + t2 ; arr [ i + len / 2 ] = t1 - t2 ; cur *= step ; } } } if ( opt == -1 ) { for ( int i = 0 ; i < lmt ; ++ i ) { arr [ i ]. real ( arr [ i ]. real () / lmt ); } } } int main () { scanf ( \"%d%d\" , & n , & m ); for ( int i = 0 ; i <= n ; ++ i ) { scanf ( \"%d\" , & k ); F [ i ]. real ( k ); } for ( int i = 0 ; i <= m ; ++ i ) { scanf ( \"%d\" , & k ); G [ i ]. real ( k ); } int lmt = 1 ; while ( lmt <= n + m ) { lmt <<= 1 ; } for ( int i = 1 ; i < lmt ; ++ i ) { rev [ i ] = ( rev [ i >> 1 ] >> 1 ) | ( i & 1 ? lmt >> 1 : 0 ); } FFT ( lmt , F , 1 ); FFT ( lmt , G , 1 ); for ( int i = 0 ; i <= lmt ; ++ i ) { F [ i ] *= G [ i ]; } FFT ( lmt , F , -1 ); for ( int i = 0 ; i <= n + m ; ++ i ) { printf ( \"%.0lf \" , fabs ( F [ i ]. real ())); } return 0 ; }","title":"\u975e\u9012\u5f52 FFT\uff08\u8774\u8776\u4f18\u5316\uff09"},{"location":"math/FFT/#fft_2","text":"","title":"FFT \u4e0e\u5b57\u7b26\u4e32\u5339\u914d"},{"location":"string/trie/","text":"Trie \u6811\u5b9e\u73b0 \u652f\u6301\u5b57\u7b26\u4e32\u7684\u63d2\u5165\u548c\u67e5\u627e\u64cd\u4f5c\u3002 \u57fa\u672c trie \u6811\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <cstdio> #include <cstring> const int MAXN = 5e5 + 5 ; int n , m ; char s [ 55 ]; int tr [ MAXN ][ 26 ], flg [ MAXN ], tot ; void ins ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) tr [ cur ][ nxt ] = ++ tot ; cur = tr [ cur ][ nxt ]; } flg [ cur ] = 1 ; } int query ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) return 0 ; cur = tr [ cur ][ nxt ]; } int ret = flg [ cur ]; if ( flg [ cur ] == 1 ) flg [ cur ] = 2 ; return ret ; } int main () { scanf ( \"%d\" , & n ); while ( n -- ) { scanf ( \"%s\" , s + 1 ); ins ( s , strlen ( s + 1 )); } scanf ( \"%d\" , & m ); while ( m -- ) { scanf ( \"%s\" , s + 1 ); int tmp = query ( s , strlen ( s + 1 )); if ( tmp == 0 ) printf ( \"WRONG \\n \" ); if ( tmp == 1 ) printf ( \"OK \\n \" ); if ( tmp == 2 ) printf ( \"REPEAT \\n \" ); } return 0 ; }","title":"Trie \u6811"},{"location":"string/trie/#trie","text":"\u652f\u6301\u5b57\u7b26\u4e32\u7684\u63d2\u5165\u548c\u67e5\u627e\u64cd\u4f5c\u3002 \u57fa\u672c trie \u6811\u5b9e\u73b0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <cstdio> #include <cstring> const int MAXN = 5e5 + 5 ; int n , m ; char s [ 55 ]; int tr [ MAXN ][ 26 ], flg [ MAXN ], tot ; void ins ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) tr [ cur ][ nxt ] = ++ tot ; cur = tr [ cur ][ nxt ]; } flg [ cur ] = 1 ; } int query ( char * ss , int len ) { int cur = 0 ; for ( int i = 1 ; i <= len ; ++ i ) { int nxt = ss [ i ] - 'a' ; if ( ! tr [ cur ][ nxt ]) return 0 ; cur = tr [ cur ][ nxt ]; } int ret = flg [ cur ]; if ( flg [ cur ] == 1 ) flg [ cur ] = 2 ; return ret ; } int main () { scanf ( \"%d\" , & n ); while ( n -- ) { scanf ( \"%s\" , s + 1 ); ins ( s , strlen ( s + 1 )); } scanf ( \"%d\" , & m ); while ( m -- ) { scanf ( \"%s\" , s + 1 ); int tmp = query ( s , strlen ( s + 1 )); if ( tmp == 0 ) printf ( \"WRONG \\n \" ); if ( tmp == 1 ) printf ( \"OK \\n \" ); if ( tmp == 2 ) printf ( \"REPEAT \\n \" ); } return 0 ; }","title":"Trie \u6811\u5b9e\u73b0"}]}